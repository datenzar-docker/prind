[server]
host: 0.0.0.0
port: 7125
klippy_uds_address: /opt/printer_data/run/klipper.sock

[machine]
provider: systemd_cli
validate_service: False

[authorization]
force_logins: true
trusted_clients:
  0.0.0.0/0
cors_domains:
  *

[octoprint_compat]
[history]

[announcements]
subscriptions:
  fluidd

[data_store]
temperature_store_size: 600
gcode_store_size: 1000

[file_manager]
# cancel object preprocessing - set to True to enable; leave disabled when running on a low-powered device (e.g. Pi Zero)
enable_object_processing: True

[secrets]

[update_manager]
enable_auto_refresh: True
# Add the following to your [update_manager] section to disable PackageKit
# This will fall back to "apt" commands. (https://github.com/Arksine/moonraker/issues/349)
enable_packagekit: False


[update_manager fluidd]
type: web
repo: fluidd-core/fluidd
path: ~/fluidd


[mqtt]
address: {secrets.mqtt_credentials.address}
port: 1883
# {secrets.mqtt_credentials.port}
username: {secrets.mqtt_credentials.username}
#   An optional username used to log in to the Broker.  This option accepts
#   Jinja2 Templates, see the [secrets] section for details. The default is
#   no username (an anonymous login will be attempted).
password: {secrets.mqtt_credentials.password}
#   An optional password used to log in to the Broker.  This option accepts
#   Jinja2 Templates, see the [secrets] section for details.  The default is
#   no password.
mqtt_protocol: {secrets.mqtt_credentials.mqtt_protocol}
#   The protocol to use when connecting to the Broker.  May be v3.1,
#   v3.1.1, and v5.  The default is v3.1.1
enable_moonraker_api: True
#   If set to true the MQTT client will subscribe to API topic, ie:
#     {instance_name}/moonraker/api/request
#   This can be set to False if the user does not wish to allow API
#   requests over MQTT.  The default is True.
instance_name: {secrets.mqtt_credentials.instance_name}
#   An identifier used to create unique API topics for each instance of
#   Moonraker on network.  This name cannot contain wildcards (+ or #).
#   For example, if the instance name is set to my_printer, Moonraker
#   will subscribe to the following topic for API requests:
#     my_printer/moonraker/api/request
#   Responses will be published to the following topic:
#     my_printer/moonraker/api/response
#   The default is the machine's hostname.
publish_split_status: False
#   Configures how to publish status updates to MQTT.
#
#   When set to False (default), all Klipper object state updates will be
#   published to a single mqtt state with the following topic:
#     {instance_name}/klipper/status
#
#   When set to True, all Klipper object state updates will be published to
#   separate mqtt topics derived from the object and item in the following
#   format:
#     {instance_name}/klipper/state/{objectname}/{statename}
#
#   The actual value of the state is published as "value" to the topic above.
#   For example, if the heater_bed temperature was 24.0, this is the payload:
#     {"eventtime": {timestamp}, "value": 24.0}
#   It would be published to this topic:
#     {instance_name}/klipper/state/heater_bed/temperature


# With this config, you can switch the printer comfortably on and off.
# https://docs.mainsail.xyz/overview/quicktips/printer-power-switch
[power printer]
type: mqtt

########################################################################################
#### MQTT Configuration (https://moonraker.readthedocs.io/en/latest/configuration/#mqtt-device-configuration)
########################################################################################

command_topic: {secrets.power_printer.command_topic}
command_payload:
  {% set my_payload = {"state": command} %}
  { my_payload|tojson }
# The response is either "ON" or "OFF".  Moonraker will handle converting to lower case.
state_topic: {secrets.power_printer.state_topic}
state_response_template:
  {% set resp = payload|fromjson %}
  {resp["state"] | lower }
state_timeout: {secrets.power_printer.state_timeout}

# Tasmota updates the state topic when the device state changes, so it is not
# not necessary to query after a command
query_after_command: False


########################################################################################
#### Moonraker Power configuration
#### https://moonraker.readthedocs.io/en/latest/configuration/#options-common-to-all-power-devices
########################################################################################

initial_state: on
#    The state the power device should be initialized to.  May be on or
#    off.  When this option is not specifed no initial state will be set.

restart_klipper_when_powered: True
#   If set to True, Moonraker will schedule a "FIRMWARE_RESTART" to command
#   after the device has been powered on. If it isn't possible to immediately
#   schedule a firmware restart (ie: Klippy is disconnected), the restart
#   will be postponed until Klippy reconnects and reports that startup is
#   complete.  Prior to scheduling the restart command the power device will
#   always check Klippy's state.  If Klippy reports that it is "ready", the
#   FIRMWARE_RESTART will be aborted as unnecessary.
#   The default is False.

# bound_services: klipper
#   A newline separated list of services that are "bound" to the state of this
#   device.  When the device is powered on all bound services will be started.
#   When the device is powered off all bound services are stopped.
#
#   The items in this list are limited to those specified in the allow list,
#   see the [machine] configuration documentation for details.  Additionally,
#   the Moonraker service can not be bound to a power device.  Note that
#   service names are case sensitive.
#
#   When the "initial_state" option is explcitly configured bound services
#   will be synced with the current state.  For example, if the initial_state
#   is "off", all bound services will be stopped after device initialization.
#
#   The default is no services are bound to the device.

